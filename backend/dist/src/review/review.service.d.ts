import { CreateReviewDto } from './dto/create-review.dto';
import { UpdateReviewDto } from './dto/update-review.dto';
import { Review } from 'entities/review';
import { Repository } from 'typeorm';
import { Product } from 'entities/Product';
export declare class ReviewService {
    private readonly reviewRepository;
    private readonly productRepository;
    constructor(reviewRepository: Repository<Review>, productRepository: Repository<Product>);
    create(createReviewDto: CreateReviewDto, userId: string, productId: string): Promise<{
        status: string;
        message: string;
        data: {
            id: string;
            rating: number;
            comment: string;
            user: import("../../entities/User").User;
            product: Product;
            createdAt: Date;
        };
    }>;
    findAll(productId: string): Promise<{
        status: string;
        message: string;
        data?: undefined;
    } | {
        status: string;
        message: string;
        data: {
            [n: number]: Review;
            length: number;
            toString(): string;
            toLocaleString(): string;
            toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
            pop(): Review;
            push(...items: Review[]): number;
            concat(...items: ConcatArray<Review>[]): Review[];
            concat(...items: (Review | ConcatArray<Review>)[]): Review[];
            join(separator?: string): string;
            reverse(): Review[];
            shift(): Review;
            slice(start?: number, end?: number): Review[];
            sort(compareFn?: (a: Review, b: Review) => number): Review[];
            splice(start: number, deleteCount?: number): Review[];
            splice(start: number, deleteCount: number, ...items: Review[]): Review[];
            unshift(...items: Review[]): number;
            indexOf(searchElement: Review, fromIndex?: number): number;
            lastIndexOf(searchElement: Review, fromIndex?: number): number;
            every<S extends Review>(predicate: (value: Review, index: number, array: Review[]) => value is S, thisArg?: any): this is S[];
            every(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): boolean;
            some(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): boolean;
            forEach(callbackfn: (value: Review, index: number, array: Review[]) => void, thisArg?: any): void;
            map<U>(callbackfn: (value: Review, index: number, array: Review[]) => U, thisArg?: any): U[];
            filter<S extends Review>(predicate: (value: Review, index: number, array: Review[]) => value is S, thisArg?: any): S[];
            filter(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): Review[];
            reduce(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review): Review;
            reduce(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review, initialValue: Review): Review;
            reduce<U>(callbackfn: (previousValue: U, currentValue: Review, currentIndex: number, array: Review[]) => U, initialValue: U): U;
            reduceRight(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review): Review;
            reduceRight(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review, initialValue: Review): Review;
            reduceRight<U>(callbackfn: (previousValue: U, currentValue: Review, currentIndex: number, array: Review[]) => U, initialValue: U): U;
            find<S extends Review>(predicate: (value: Review, index: number, obj: Review[]) => value is S, thisArg?: any): S;
            find(predicate: (value: Review, index: number, obj: Review[]) => unknown, thisArg?: any): Review;
            findIndex(predicate: (value: Review, index: number, obj: Review[]) => unknown, thisArg?: any): number;
            fill(value: Review, start?: number, end?: number): Review[];
            copyWithin(target: number, start: number, end?: number): Review[];
            entries(): ArrayIterator<[number, Review]>;
            keys(): ArrayIterator<number>;
            values(): ArrayIterator<Review>;
            includes(searchElement: Review, fromIndex?: number): boolean;
            flatMap<U, This = undefined>(callback: (this: This, value: Review, index: number, array: Review[]) => U | readonly U[], thisArg?: This): U[];
            flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
            [Symbol.iterator](): ArrayIterator<Review>;
            [Symbol.unscopables]: {
                [x: number]: boolean;
                length?: boolean;
                toString?: boolean;
                toLocaleString?: boolean;
                pop?: boolean;
                push?: boolean;
                concat?: boolean;
                join?: boolean;
                reverse?: boolean;
                shift?: boolean;
                slice?: boolean;
                sort?: boolean;
                splice?: boolean;
                unshift?: boolean;
                indexOf?: boolean;
                lastIndexOf?: boolean;
                every?: boolean;
                some?: boolean;
                forEach?: boolean;
                map?: boolean;
                filter?: boolean;
                reduce?: boolean;
                reduceRight?: boolean;
                find?: boolean;
                findIndex?: boolean;
                fill?: boolean;
                copyWithin?: boolean;
                entries?: boolean;
                keys?: boolean;
                values?: boolean;
                includes?: boolean;
                flatMap?: boolean;
                flat?: boolean;
                [Symbol.iterator]?: boolean;
                readonly [Symbol.unscopables]?: boolean;
                at?: boolean;
            };
            at(index: number): Review;
        };
    }>;
    getAllReviewsByUser(userId: string): Promise<{
        status: string;
        message: string;
        data?: undefined;
    } | {
        status: string;
        message: string;
        data: {
            [n: number]: Review;
            length: number;
            toString(): string;
            toLocaleString(): string;
            toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
            pop(): Review;
            push(...items: Review[]): number;
            concat(...items: ConcatArray<Review>[]): Review[];
            concat(...items: (Review | ConcatArray<Review>)[]): Review[];
            join(separator?: string): string;
            reverse(): Review[];
            shift(): Review;
            slice(start?: number, end?: number): Review[];
            sort(compareFn?: (a: Review, b: Review) => number): Review[];
            splice(start: number, deleteCount?: number): Review[];
            splice(start: number, deleteCount: number, ...items: Review[]): Review[];
            unshift(...items: Review[]): number;
            indexOf(searchElement: Review, fromIndex?: number): number;
            lastIndexOf(searchElement: Review, fromIndex?: number): number;
            every<S extends Review>(predicate: (value: Review, index: number, array: Review[]) => value is S, thisArg?: any): this is S[];
            every(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): boolean;
            some(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): boolean;
            forEach(callbackfn: (value: Review, index: number, array: Review[]) => void, thisArg?: any): void;
            map<U>(callbackfn: (value: Review, index: number, array: Review[]) => U, thisArg?: any): U[];
            filter<S extends Review>(predicate: (value: Review, index: number, array: Review[]) => value is S, thisArg?: any): S[];
            filter(predicate: (value: Review, index: number, array: Review[]) => unknown, thisArg?: any): Review[];
            reduce(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review): Review;
            reduce(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review, initialValue: Review): Review;
            reduce<U>(callbackfn: (previousValue: U, currentValue: Review, currentIndex: number, array: Review[]) => U, initialValue: U): U;
            reduceRight(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review): Review;
            reduceRight(callbackfn: (previousValue: Review, currentValue: Review, currentIndex: number, array: Review[]) => Review, initialValue: Review): Review;
            reduceRight<U>(callbackfn: (previousValue: U, currentValue: Review, currentIndex: number, array: Review[]) => U, initialValue: U): U;
            find<S extends Review>(predicate: (value: Review, index: number, obj: Review[]) => value is S, thisArg?: any): S;
            find(predicate: (value: Review, index: number, obj: Review[]) => unknown, thisArg?: any): Review;
            findIndex(predicate: (value: Review, index: number, obj: Review[]) => unknown, thisArg?: any): number;
            fill(value: Review, start?: number, end?: number): Review[];
            copyWithin(target: number, start: number, end?: number): Review[];
            entries(): ArrayIterator<[number, Review]>;
            keys(): ArrayIterator<number>;
            values(): ArrayIterator<Review>;
            includes(searchElement: Review, fromIndex?: number): boolean;
            flatMap<U, This = undefined>(callback: (this: This, value: Review, index: number, array: Review[]) => U | readonly U[], thisArg?: This): U[];
            flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
            [Symbol.iterator](): ArrayIterator<Review>;
            [Symbol.unscopables]: {
                [x: number]: boolean;
                length?: boolean;
                toString?: boolean;
                toLocaleString?: boolean;
                pop?: boolean;
                push?: boolean;
                concat?: boolean;
                join?: boolean;
                reverse?: boolean;
                shift?: boolean;
                slice?: boolean;
                sort?: boolean;
                splice?: boolean;
                unshift?: boolean;
                indexOf?: boolean;
                lastIndexOf?: boolean;
                every?: boolean;
                some?: boolean;
                forEach?: boolean;
                map?: boolean;
                filter?: boolean;
                reduce?: boolean;
                reduceRight?: boolean;
                find?: boolean;
                findIndex?: boolean;
                fill?: boolean;
                copyWithin?: boolean;
                entries?: boolean;
                keys?: boolean;
                values?: boolean;
                includes?: boolean;
                flatMap?: boolean;
                flat?: boolean;
                [Symbol.iterator]?: boolean;
                readonly [Symbol.unscopables]?: boolean;
                at?: boolean;
            };
            at(index: number): Review;
        };
    }>;
    findOne(id: string): Promise<{
        status: string;
        message: string;
        data: Review;
    }>;
    update(id: string, updateReviewDto: UpdateReviewDto, userId: string): Promise<{
        status: string;
        message: string;
        data: Review;
    }>;
    remove(id: string, userId: string): Promise<{
        status: string;
        message: string;
    }>;
}
